
[INDEX]
 - 오라클 데이터베이스 테이블 내의 원하는 레코드를 빠르게 검색 할 수 있도록 만들어진 데이터 구조 
 - 속도가 빨라질 수도 있지만, 떨어지는 경우도 있다.
 - Optimizer : 최적의 처리경로를 생성 해주는 DBMS 내부의 핵심엔진
 
 1) 특성 
  - 연관된 객체의 데이터와 논리적·물리적으로 독립적인 스키마 객체 
  - 테이블에 영향을 주지 않고 삭제·생성이 가능 
  
 2) 생성 방법
  - 자동 인덱스 : PRIMARY KEY or UNIQUE 제약조건에 의해 자동 생성
  - 수동 인덱스 : CREATE INDEX 명령 실행 
  
 3) 고려사항 
  - 인덱스가 항상 나은 성능을 보장하지는 않는다. 
  - 조건 절에 사용하는 컬럼의 위치에 따라 인덱스가 달라 질 수 있다.
  
  - I/D/U 가 얼마나 발생하는지 고려해야 한다. (INDEX 는 DML 에 취약)
    → INDEX : INDEX Split 현상 발생 (인덱스의 블록들이 하나에서 두개로 나누어짐)
    → DELETE : 레코드를 삭제 하여도 인덱스는 지워지지 않아 성능이 현저히 떨어질 수 있음 
    → UPDATE : 인덱스에는 update 개념이 없어서 부하가 큼 
    
  - 타 쿼리 실행에 악영향을 줄 수 있다.
  - 인덱스는 추가적인 저장 공간을 필요로 한다.
  
  * 인덱스를 사용해야 하는 경우
   - WHERE 절이나 JOIN 절에서 자주  사용되는 컬럼
   - 값이 아주 드물게 존재하는 컬럼 
   - 검색 결과가 2~4% 정도 되는 컬럼 
   - 자주 조합되어 사용되는 컬럼 > 결합 인덱스 생성 
   
  * 사용하지 말아야 하는 경우 
   - 테이블에 관리되는 데이터 양이 적은 경우 (그냥 찾는게 빠름)
   - WHERE 문에 해당 컬럼이 자주 사용되지 않는 경우
   - 검색 결과가 10~15% 정도 되는 컬럼
   - 테이블에 DML 작업이 많은 경우 (I/U/D) 
   
  * 사용되지 않는 경우 
   - 컬럼이 비교되기 전에 변형이 일어난 경우 ex) sal+100 > 200 (인덱스 안먹음)
   - 부정형(NOT) 조건 기술한 경우
   - 인덱스 컬럼이 NULL로 비교되는 경우 
   
 4) 인덱스 분류 (by 컬럼 속성, 유형) 
  - Unique and Nonunique Indexes 
    - 고유 인덱스 : 유일한 값을 갖는 컬럼에 대해서만 인덱스 설정 가능 
    - 비 고유 인덱스 : 중복값을 갖는 컬럼에 대해서 인덱스 설정 
    
  - Single and Composite Indexes 
    - 단일 인덱스 : 하나의 컬럼을 사용하여 인덱스 설정 
    - 결합 인덱스 : 두개 이상의 컬럼을 사용하여 인덱스 설정. AND 연산만. OR 연산은 인덱스를 만들지 않는다. 
    
 5) 인덱스 종류 
  - B-Tree indexes 
    ------------------------------------------------------------------
     CREATE INDEX 인덱스명 ON 테이블명(컬럼명, ...); 
    ------------------------------------------------------------------
    - 관계형 데이터베이스에서 가장 일반적으로 사용되는 인덱스 
    - 기본키 및 선택성이 높은 인덱스에 적합 
    - 데이터 값 종류가 많고 중복적인 데이터가 적은 경우에 사용 
    - 테이블 레코드를 가리키는 ROWID 목록을 키 값과 함께 저장하는 구조 
    - 인덱스 된 컬럼별로 정렬된 데이터를 검색 할 수 있음 
    - Reverse key indexes / Descending indexes / B-tree cluster indexst 
    
  - Bitmap 인덱스 
    ------------------------------------------------------------------
     CREATE BITMAP INDEX 인덱스명 ON 테이블명(컬럼명, ...);
    ------------------------------------------------------------------
    - 그룹별 인덱스 (비트맵을 사용하여 여러 행을 가리킴)
    - 2진수 형태의 비트로 관리 
    - 대량의 데이터를 한꺼번에 입력한 뒤 분석이나 통계 정보를 출력 할 때 많이 사용 
    
  - 함수 기반 인덱스 
    - 인덱스에서 하나 이상의 컬럼 및 저장을 수반하는 기능 또는 식의 값을 계산 
    
  - 응용 프로그램 도메인 인덱스 


    * 예제 
      SELECT name, sal FROM emp WHERE name='심심해';
       
      - B-Tree 인덱스 
        CREATE INDEX idx_emp_name ON emp(name);
	 
        SELECT * FROM user_indexes WHERE table_name='EMP';
       
        DROP INDEX idx_emp_name;
        
      - 결합 인덱스 (검색 결과를 더 많이 줄일 수 있는 컬럼부터 사용 할 것) 
        CREATE INDEX idx_emp_comp ON emp(name, city);
        SELECT name, city FROM emp WHERE name = '심심해' AND city = '전북';
        DROP INDEX idx_emp_comp;
         
     - 함수 기반 인덱스 
        CREATE INDEX idx_emp_fun ON emp(MOD(SUBSTR(rrn,8,1),2)); 
        DROP INDEX idx_emp_fun;
     
     
 6) 인덱스 관리
    - 인덱스는 입력만 되고 삭제가 되지 않으므로, 데이터가 삭제 될 때 인덱스로 인해 속도 저하가 발생 할 수 있다.
      → 대량의 DML 작업 후 인덱스의 관리가 필요 
					
       ------------------------------------------------------------------
       ALTER INDEX 인덱스명 REBUILD;    -- 인덱스 재생성 
       ------------------------------------------------------------------
    
    - 인덱스 활용과 관련된 데이터를 수집 (인덱스 사용 유무 확인)
       ------------------------------------------------------------------
       ALTER INDEX 인덱스명 [NO]MONITORING USAGE;   -- 인덱스 모니터링 시작[중지]
       SELECT * FROM V$OBJECT_USAGE;  -- 모니터링 결과 확인 
       ------------------------------------------------------------------
    
    - 인덱스 분석 
       ------------------------------------------------------------------
       ANALYZE INDEX 인덱스명 VALIDATE STRUCTURE;     
       ------------------------------------------------------------------

       ANALYZE INDEX idx_test22_num VALIDATE STRUCTURE;
       
       SELECT * FROM index_stats;
       SELECT (del_lf_rows_len / lf_rows_len) * 100 
       FROM index_stats
       WHERE name = 'IDX_TEST22_NUM';     -- 0에 가까우면 좋은 상태 
