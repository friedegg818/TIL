# Express.js
  - HTTP 요청에 대하여 라우팅 및 미들웨어 기능을 제공하는 웹 프레임워크

  #### 라우팅(routing)
   - URL(URI) 요청에 따라 어플리케이션이 응답하는 방법을 결정
   - 기본적으로 어플리케이션 서버에서 경로를 제어하는 목적
   - 목적지까지 갈 수 있는 여러 경로 중 한 가지 경로를 설정해 주는 과정

  #### 미들웨어(middleware)
   - 중간에 끼워 넣는다는 의미로 부가적인 기능이나 처리를 제공하는 목적
   - 이기종의 환경을 연결해주는 소프트웨어
   - Express.js 에서 사용할 수 있는 중간처리 목적의 소프트웨어 / 모듈
   - 최종 요청 핸들러 이전의 Express 라우팅 계층에 의해 호출되는 함수
 
          ** 사이트
             https://expressjs.com/
             https://www.npmjs.com/package/express

          ** express API
             http://expressjs.com/ko/4x/api.html
             http://expressjs.com/ko/guide/routing.html

#
## Express 외부 모듈 설치
   - Express 에는 Web 응용 프로그램을 위한 기본적인 시스템이 구축되어 있음
   - 다양한 객체를 이용하여 아주 쉽게 필요한 처리를 조합 가능
   - 버전업 되면 사용법이 달라질 수 있음

   ### express-generator 로 설치
   - express 프로젝트의 기본 형식을 만들어주는 커맨드 모듈
   - 설치
	  
            C:\nodejs> npm install express-generator -g

             -g 옵션은 글로벌 모듈 설치로 시스템 디렉토리에 설치

   ### express-generator 으로 설치하지 않는 경우 

   1. npm을 초기화
   
            C:\nodejs> npm init
      
            이름, 버전, 설명문, 엔트리 포인트, 테스트 명령, git 저장소, 키워드, 저자, 라이선스 등을 차례로 가져옴
	        잘 모르는 경우 전부 그대로 Enter 키 >  package.json 파일 생성

   2. Express 설치
   
            C:\nodejs> npm install express --save
	    
             --save 옵션을 통해 설치된 Node 모듈은 package.json 파일 내의 dependencies 목록에 추가 됨
	          이 후 app 디렉토리에서 npm install 을 실행하면 종속 항목 목록 내의 모듈이 자동으로 설치 (생략 가능)

              → 응용 프로그램의 "nodejs"에 "node_modules"라는 폴더 생성
	            그 안에 'express'라는 폴더가 저장 됨 (Express 파일이 저장되는 폴더)


   3. EJS를 설치   
    - Express에서 템플릿 엔진으로 사용하는 EJS을 설치

             C:\nodejs> npm install ejs

            →  "node_modules" 폴더에 "ejs"폴더가 생성 (파일이 저장 됨)
	     
#
   ### 프로젝트 생성  
   - 형식
	  
          express [폴더명(프로젝트명)] [-옵션] [--옵션]

		  ** 옵션
		      -h, --help         : Express generator 도움말
		      -V, --version      : Express generator 버전 확인
		      
		      -e, --ejs          : 템플릿 렌더링 모듈을 ejs로 설정 (기본은 jade)
		      
		      --hbs              : handlebars engine을 사용
		      -H, --hogan        : hogan.js 엔진 모듈을 사용
		      
		      -c, --css <engine> : 스타일시트 엔진 설정. 
		                           <sass, less, stylus, compass> 기본은 plain css
					   
		      --git              : .gitnore를 추가해서 git과 연동할 수 있게 생성
		      -f, --force        : 해당 폴더가 비어 있지 않아도 강제로 작업
 
  - 프로젝트 생성
	  
            C:\nodejs> express myapp --ejs --css sass

            → 자동으로 파일 및 폴더들이 생성 되며, package.json 파일도 세팅
              웹 템플릿으로 ejs 모듈을 사용하고, css 모듈로 sass를 사용
	      

            C:\nodejs> cd myapp
            C:\nodejs\myapp> npm install

            → 필요한 모듈들을 모두 다운로드하고 설치. 기본 세팅 끝 
#
   ### 테스트
   
           C:\nodejs\myapp> set DEBUG=myapp:* & npm start
            or
           C:\nodejs\myapp> npm start

           →  http://localhost:3000/ 에서 확인

#
  ### 프로젝트 폴더 구조 및 포트 변경
  #### 프로젝트 폴더 구조
	 
   **ㆍbin**
       
              실행하는 프로그램이 저장되어 있는 곳
              'www' → 응용 프로그램의 실행 스크립트 파일
			  
   **ㆍnode_modules**
   
               Node.js에서 사용하는 모듈(Express 등 각종 프로그램과 필요한 파일)들이 정리 되어 있는 곳        
	   
   **ㆍpublic**
       
               http 서버의 root 폴더로 공개 파일을 설치 하는 곳
	           이 곳에 배치하면 Express 에서 사용 가능
          	ex) 이미지 파일 및 JavaScript 라이브러리, 스타일시트 파일 등         
			   
   **ㆍroutes**
       
               각각의 Web 페이지에서 처리 할 스크립트 파일들이 있는 곳
               Express가 생성한 Web 어플리케이션에서는 스크립트 관련의 주요 처리 부분과 개별 페이지의 처리가 별도의 폴더로 나누어짐
	       
               각각의 페이지 처리가 보관 됨
               사이트의 어떤 주소를 입력했을 때 어디로 연결해 줄지를 결정해주는 javascript 파일들을 모아 놓은 곳
			   
   **ㆍviews**
       
               페이지 템플릿 파일들을 정리
               화면 표시를 위한 필요한 파일들 준비
			   
   **ㆍapp.js 파일**
       
               메인 프로그램이 되는 스크립트 파일
               Node.js으로 프로그램을 실행할 때에 이 파일은 지정하지 않고 
               bin 폴더에 있는 www에서 app.js를 호출 실행
			   
   **ㆍpackage.json 파일**
       
               Web 어플리케이션의 패키지 정보를 기술한 파일

 #### 포트 변경
   - bin 폴더의 www 파일에서 15 라인의 **3000**을 원하는 번호로 변경
         
         var port = normalizePort(process.env.PORT || '3000');
   

#
  #### 모듈 분석
   **1. package.json**   
		
	  	  ------------------ 시작 -------------------
		  
	 	   {
		    "name": "myapp",
		    "version": "0.0.0",
		    "private": true,
		    "scripts": {
		  	  "start": "node ./bin/www"
		    },
		    "dependencies": {
			  "cookie-parser": "~1.4.3",
			  "debug": "~2.6.9",
			  "ejs": "~2.5.7",
			  "express": "~4.16.0",
			  "http-errors": "~1.6.2",
			  "morgan": "~1.9.0"
			  "node-sass-middleware": "0.11.0"
		     }
		    }
		    
		   ----------------- 종료 --------------------
	
   - 분석	
 	
	name : 이름 
	version : 버전 
	private : 배포 여부 
				
	npm scripts : start를 하면 bin 폴더에 있는 www를 실행 

	dependencies				
	  ㆍ body-parser          : 파일들의 형식에 따라 내부 내용을 읽어서 사용할 수 있게 해주는 모듈
			            JSON, Raw, Text, URLencoded 형식의 내용들을 파싱 해 줌
	  ㆍ Cookie-parser        : 쿠키를 파싱해서 사용 할 수 있게
	  
	  ㆍ debug                : 디버그를 위한 모듈
	  ㆍ ejs                  : 웹페이지 템플릿 모듈
	  
	  ㆍ express              : express
	  ㆍ morgan               : express 서버가 클라이언트들과 주고받는 내용들을 log로 남김
	  
	  ㆍ node-sass-middleware : sass 파일을 css로 컴파일하여 매핑 해 주는 모듈
	  ㆍ server-favicon       : favicon을 설정. 파비콘은 웹페이지를 실행하면 위에 타이틀 옆에 뜨는 글자
						   

   2. ./bin/www 파일 주요 내용
		
			// -----------------------------------------------------
			var app = require('../app');
			var debug = require('debug')('myapp:server');
			var http = require('http');
			// -----------------------------------------------------

					  - app은 위 폴더에 있는 app.js 파일을 가져온다. app.js 파일에는 각종 express 설정들이 들어간다.
					  - debug는 위하여 선언해준다.
					  - http는 http 서버를 열기 위해서 필요하다. 

			// -----------------------------------------------------
			var port = normalizePort(process.env.PORT || '3000');
			app.set('port', port);
			// -----------------------------------------------------

					  - port는 환경변수에 PORT 이름으로 저장되어 있는 포트로 열고, 없다면 3000번으로 열게 된다.

			// -----------------------------------------------------
			var server = http.createServer(app);
			// -----------------------------------------------------

					  - express 정보와 위의 포트 정보가 담겨있는 app 변수를 이용하여 http 서버를 생성한다.

			// -----------------------------------------------------
			server.listen(port);
			server.on('error', onError);
			server.on('listening', onListening);
			// -----------------------------------------------------

					  - server를 실행한다.

   3. ./app.js 파일 주요 내용		
      - 라이브러리 로드
		   
             var express = require('express');
             var path = require('path');
             var favicon = require('serve-favicon');
             var logger = require('morgan');
             var cookieParser = require('cookie-parser');
             var bodyParser = require('body-parser');

             var routes = require('./routes/index');
             var users = require('./routes/users');

              express : Express 객체의 변수
              path : Path 객체
              serve-favicon : favicon (Web 페이지에 표시되는 아이콘 데이터)에 관한 것
              morgan : 로그 출력에 대한 객체
              cookie-parser : 쿠키 이용에 관한 객체
              body : Parser 바디 부분의 파싱과 관련된 객체
              routes : routes 폴더에 설치되어 있는 index.js의 객체
              user : routes 폴더에 설치되어있는 user.js의 개체

      - express 함수로 Application 만들기
		   
              var app = express();

      - 각종 어플리케이션 설정하기
		   
              app.set('views', path.join(__dirname, 'views'));
              app.set('view engine', 'ejs');

              app.use(logger('dev'));
              app.use(bodyParser.json());
              app.use(bodyParser.urlencoded({ extended: false }));
              app.use(cookieParser());
              app.use(express.static(path.join(__dirname, 'public')));

      - get으로 루트 설정하기
		   
              app.use('/', routes);
              app.use('/users', users);

              get으로 '/'와 '/users' 주소에 각각 routes과 users 변수를 설정
              routes 폴더에 있는 index.js와 users.js을 각각 require으로 로드한 것을 얻은 변수

      - 에러 처리 설정
		   
              app.use(function(req, res, next) {
                var err = new Error('Not Found');
                err.status = 404;
                next(err);
              });

              if (app.get('env') === 'development') {
                app.use(function(err, req, res, next) {
                  res.status(err.status || 500);
                  res.render('error', {
                    message: err.message,
                    error: err
                  });
                });
              }

              app.use(function(err, req, res, next) {
                res.status(err.status || 500);
                res.render('error', {
                  message: err.message,
                  error: {}
                });
              });

              app.use, if문 또한 app.use 계속되지만, 이러한 에러에 대한 처리를 수행하는 것이다.

      - 어플리케이션 설정
		   
              module.exports = app;

#
### Express 템플릿 엔진
   #### Jade
   - Express가 기본으로 제공하는 템플릿 엔진
   - 템플릿 엔진 : 파일을 읽어들일 때에 엔진의 규칙과 설정에 의해 파일을 변환시키고, 화면에 출력시켜주기 위한 HTML 형식으로 바꿔주는 모듈
   - Jade 모듈 또한 같은 역할
   - Jade 문법대로 파일을 작성하면, 이를 Express에서 엔진을 사용하여 사용자에게 보여지기 위한 형태로 바꿈
   - 이를 설정하는 곳은 express 폴더 내부의 ./app.js 파일의 다음부분이다.
	  
          // view engine setup
          app.set('views', path.join(__dirname, 'views')); // 14
          app.set('view engine', 'jade');                           // 15

          14번 15번 줄이 엔진을 설정하는 곳인데, 14번은 엔진을 통해서 렌더링할 파일이 들어갈 폴더를 지정해준다.

          15번은 14번에 해당하는 폴더의 파일을 jade engine으로 변환하겠다는 내용
		  

			// - jade 파일 예 -----------------------------------------
			doctype html
			html(lang="ko")
			  head
				title= pageTitle
				script(type='text/javascript').
				  var isJade = 1;
			  body
				h1 Jade - node template engine
				#container.col
				  p Jade가 어렵나요?
				  p(style="display:inline;").
					Jade는 조금 이해하기 어려운 면이 있다.
					indentation을 반드시 지켜야 한다.
					익숙해지면 굉장히 편하고, 깔끔할지도 모른다.
			//-------------------------------------------------------

			// - jade 파일을 jade 엔진으로 렌더링 결과 ------------------
			<!DOCTYPE html>
			<html lang="ko">
			<head>
				<title>Jade</title>
				<script type="text/javascript">var isJade = 1;</script>
			</head>
			<body>
				<h1>Jade - node template engine</h1>
				<div id="container" class="col">
				  <p>Jade가 어렵나요?</p>
				  <p style="display:inline;">
					Jade는 조금 이해하기 어려운 면이 있다.
					indentation을 반드시 지켜야 한다.
					익숙해지면 굉장히 편하고, 깔끔할지도 모른다.
				  </p>
				</div>
			</body>
			</html>
			//-------------------------------------------------------

				   - jade 파일을 보면, html 태그의 <> 부호가 사라졌다.
				   - 태그를 열고 닫는 것은 indent로 대체한다. 즉 앞에 띄어쓰기 혹은 Tab이 얼마나 되어있느냐를 기준으로 자동으로 태그를 열고 닫아준다.

				   - 익숙해지면 빠르고 짧은 코딩이 가능하겠지만, 불편하며 ejs 모듈은 html 및 jsp와 유사한 형식을 사용한다.

#
#### EJS
  - Embedded JavaScript 의 약자로, 내부에 javascript 를 집어 넣어둔다는 의미
  - 사용법은 크게 EJS 문서 내부의 문법과 Render 할 때에 변수(또는 object)를 넘김
  - 문서 내부에서는 위에서 처럼 JSP와 유사한 방식을 사용

			   <% 임시로 작동할 코드들 %>
			   <%= 라우터에서 받은 객체들, escaped character%> : <b></b> 와 같은 태그를 문자열로 처리(그대로 출력)
			   <%- unescaped character%> : <b></b> 와 같은 태그를 html 태그로 처리

			   예를 들면

				<% if (user) {%>
					<h2><%= user.name%></h2>
				<% }%>

				만약 Render할 때에 user라는 객체를 넘겨 받았다면,
				<h2>태그 안에 user.name 을 출력시킨다.

				<% %> 내부에는 보통 조건문, 반복문을 주로 사용하고 <%= %>가 매우 유용하게 쓰인다.

			   - html로 띄우기 전에 <%%> 내부를 먼저 수정하므로 html의 속성들 속에도 들어갈 수 있고, 서버에서 일어나는 작업들을 html에서는 숨길 수 있다.
			   - 문서를 Render할 때에 객체를 넘기는 것은 Router에서 해주어야 한다.
				  router.get('/skin', function(req, res, next){
					  res.render('skin');
				  });

				  위의 코드는 render할 때에 넘기는 객체 없이 skin.ejs 파일을 html로 컴파일한다.

				  router.get('/skin', function(req, res, next){
					  res.render('skin', {user:{name:'hong'}});
				  });

				  위와 같이 사용하면 user라는 객체를 넘기는데, json 형태로 넘어가기 때문에 내부 조건들에 접근할 수 있다.
