# 상속
- 기존에 있던 메소드와 필드를 그대로 물려준 새로운 클래스 
 
       Super class 상위 클래스 (a) : 상속을 해주는 부모. 상위 or 기반 클래스    
	   	   ↓   
       Sub class 하위 클래스 (a+b) : 상속을 받는 자식. 하위 or 파생 클래스 

- **is-a 관계** (상속 관계)

         _ B > A 
           → B가 A에게 물려줌 
	     = A가 B에게 상속 받음 
             = A는 B이다 
	     = is-a 관계  
			   
- **has-a 관계** (포함 관계) 

       _ 하나의 클래스가 다른 클래스의 멤버를 가지고 이용하는 구조 
          → A 클래스는 B라는 객체를 포함한다. 

#
- **하위 클래스**

      [public class B extends A ( )]
      
      · B는 A의 하위 클래스   
      · 상위 클래스가 있어야 한다.
      · 상위 클래스가 없을경우, 최상위 상속자는 Object 
      · java는 하나의 클래스만 상속 받을 수 있다. (다중 상속 지원 X)
      · 생성자, 초기화 블록은 상속 X 
      · private 접근 제한자가 붙은 경우 상속 X 
      · 같은 이름을 가진 것이 있으면, 우위는 B에 있다. (A의 변수는 무시) → super 이용

#
- **접근 제어자** 
  - private < default < protected < public 
 


		public class Ex01_inheritance {
			public static void main(String[] args) {
				Demo1 d = new Demo1(); // Demo1만 메모리 할당 
				System.out.println(d.b);
				// d.print(); // print()는 자식 것. (하위 클래스의 필드나 메소드는 상위 클래스가 접근 불가) 

				Test1 t=new Test1(); // Test1에 메모리 할당 하면, Demo1도 메모리 할당 됨  
				t.write();
				// System.out.println(t.a)); // private이므로 상속 안 됨 
				System.out.println(t.b+":"+t.c);

				t.print();

			}
		}
#
		class Demo1 { 		// 아버지 : Object (extends 없을 경우) 
			private int a=10; 
			protected int b=20;
			public int c=30;

			public void write() { 
				System.out.println(a+":"+b+":"+c);
			}	
		}
#
		class Test1 extends Demo1 { 	// 아버지 : Demo1 
			int x=100;

			public void print() {
				System.out.println(x+":"+b+":"+c);
			 //	System.out.println(a); // 컴오류
			}

			public void fun() { 
				write(); 
			}	
		} 

#
- **[super] 키워드** 
  - 현재 클래스에서 상속받은 상위 클래스의 객체를 가르킴
  - 하위 클래스 내에서만 사용 가능  
									 
		public class Ex02_inheritance_super {
		public static void main(String[] args) {
			Test2 tt = new Test2();
			tt.print();

			System.out.println(tt.a + ":" + tt.b + ":" + tt.c + ":" + tt.d);
			// 10:20:200:300
			// System.out.println(tt.super.c); // super나 this는 클래스 내에서만 사용 가능
			System.out.println(((Demo2) tt).c);
		}
	}

		class Demo2 {
			int a = 10;
			int b = 20;
			int c = 30;

			public void write() {
				System.out.println(a + ":" + b + ":" + c);
			}
		}

		class Test2 extends Demo2 {
			int c = 200;
			int d = 300;

			public void print() {
				int a=1; 
				System.out.println(a + ":" + b + ":" + c + ":" + d); // 1:20:200:300 // a > 지역변수 우선
				System.out.println(this.a + ":" + this.b + ":" + this.c + ":" + this.d); // 10:20:200:300
				System.out.println(super.a + ":" + super.b + ":" + super.c + ":" + c); // 10:20:30:200
			}
		}

#
### 클래스 상속과 생성자 
- 모든 생성자에는 눈에 안 보이는 한 줄이 존재 
- 모든 클래스의 생성자는 첫줄에서 반드시 다음을 호출 해야 한다.   
   1) this(); > 자신의 클래스에 정의된 다른 생성자      
   2) super(); > 상위 클래스의 생성자   
	→ 생성자의 최상단에서 한번만 가능   
        → 호출하지 않으면 컴파일러가 자동으로 super(); 디폴트 생성자를 추가한다.   
	→ 단, 상위 클래스에 '인자 있는 생성자만' 있으면,    
	  하위 클래스는 명시적으로 인자 있는 상위 클래스 생성자를 호출 해야 한다. (없으면 컴오류)    
  
		public class Ex03_inheritance_super {
		public static void main(String[] args) {

			Test3 tt1 = new Test3(); 
				// 1) new 로 Demo3 의 a와 Test3의 x 메모리 할당 및 0으로 초기화 
				// 2) Test3() 생성자의 첫 줄 실행  > this(100); > Test3(int x) 생성자 코드 실행
				// 3) Test3(int x) 생성자의 첫 줄 실행  > super(); > Demo3() 생성자 코드 실행
				// 4) Demo3() 생성자의 첫 줄 실행 > super(); > Object() 생성자 코드 실행 
				// 5) Demo3() 생성자 나머지 코드 실행 
				//    - 여기부터 거꾸로 실행 - 
				// 6) Test3(int x) 생성자 나머지 실행       
				// 7) Test3() 생성자 나머지 실행 

			tt1.write();		
		}
	}
#
		class Demo3 { 
			int a=10; 

			public Demo3() { 
				// super(); 가 숨어 있음 
				System.out.println("인자 없는 Demo3 생성자"); 
				a=10; 
			}

			public Demo3(int a) { 
				System.out.println("인자 있는 Demo3 생성자"); 
				this.a=a; 
			}

			public void print() {
				System.out.println("a:"+a);
			}
		}
#
		class Test3 extends Demo3 { 
			int x;

			public Test3() { 
				// super(); 안 부름 , this를 불렀기 때문에 
				// 다른 생성자(in 동일 클래스)는 최상단에서 한 번만 부를 수 있다. 
				// 다른 생성자를 호출하지 않으면 super();로 상위 생성자 호출 
				this(100);
				System.out.println("Test3 인자 없는 생성자");
			}

			public Test3(int x) { 	
				// super(); 가 숨어 있음 
				this.x=x;
				System.out.println("Test3 인자 하나 생성자");
			}	

			public Test3(int a, int x) { 
				super(a); // 슈퍼 클래스의 생성자 호출. 최상단에서 한번만 가능. 
				this.x=x; 
				System.out.println("Test3 인자 둘 생성자");
			}	

			public void write() {
				System.out.println(a+":"+x);
			}	
		}
	
#	
### 메소드 오버라이딩
- 재정의 
- 상위 클래스에 정의된 메소드를 기능은 유지하면서 변형시킴 
- 오버라이딩 되면, 상위 클래스의 기존 메소드는 부를 수 없다.(숨는 효과) → super 사용(내부에서만 가능)
- 규칙
  · 반드시 상속 관계에서만 
  · 메소드이름/리턴타입/인자의 자료와 갯수 완전 일치해야함 
  · 접근제어자는 크거나 같아야 함 
  · 예외를 뺄 수는 있지만, 추가 할 수는 없다
  · final, private, static > 재정의 불가 

- 어노테이션 
  : 컴파일러에게 오버라이딩 했다고 알려주는 것 
  
  public class Ex06_overriding {
	public static void main(String[] args) {
		Test6 ob = new Test6();    
		ob.print();   // Test6 의 print 실행 
	}
}

	class Demo6 {
		int a=10;
		public void print() { // print1
			System.out.println(a);
		}	
	}

	class Test6 extends Demo6 {
		int x=100;
		
	/*	
		public void print(int x) {       // 중복정의
			System.out.println(a+":"+x);
	*/
		
		@Override						  // 어노테이션
		public void print() {			  // 재정의 (print2)
			System.out.println(a+":"+x);
		}
		
		public void fun() { 
			print();  // print2 호출 
			super.print(); // print1 호출 
		}		
	}
	
	public class Ex07 {
	public static void main(String[] args) {
		Demo7 dd1 = new Demo7();
		Demo7 dd2 = new Demo7();

		System.out.println(dd1.equals(dd2)); // 주소비교. false
		// Object의 equals() 호출

		System.out.println(dd1); // 클래스이름@해쉬코드
		System.out.println(dd1.toString()); // 클래스이름@해쉬코드

		Test7 tt1 = new Test7();
		Test7 tt2 = new Test7();
		System.out.println(tt1.equals(tt2)); // 1)
		// Test7에 재정의 된 equals() 호출

		System.out.println(tt1); // a:100
		System.out.println(tt1.toString()); // a:100
		}
	}

	class Demo7 {
		int a = 10;

		public void print() {
			System.out.println(a);
		}
	}

	class Test7 {
		int a = 100;

		public void write() {
			System.out.println(a);
		}

		@Override
		public boolean equals(Object obj) { 		// equals 재정의
			Test7 t = (Test7) obj; 		// obj는 1)의 tt2
			return this.a == t.a; 		// this는 1)의 tt1
			// return a==t.a;
		}

		@Override
		public String toString() {
			return "a:" + a;
		}
	}
	
<레퍼런스 변수의 형 변환>	
- 레퍼런스 변수에서 서로 다른 인스턴스나 레퍼런스가 할당 되었을 때 
- 규칙 
· 상속 관계의 클래스 사이에서만 가능 (형제관계 X)
· 업 캐스팅 - 언제나 가능 
         - 상위 클래스 객체는 하위 클래스 객체로 소속됨 
		 - 필드 → 본래 자신이 가지고 있는 값 
		 - 메소드 → 하위 클래스가 가지고 있는 식 
		          단, 오버라이딩 된 메소드만 가능 			   
				  (하위 클래스에서 메소드가 재정의 되면 상위 클래스의 메소드는 숨는다) 
				  (클래스 내부에서는 super를 이용하면 되지만 외부에서는 절대 불가능하다) 
	
· 다운 캐스팅 - 업 캐스팅 후에만 가능. 강제 형변환 필요 → (캐스팅)
          - 다운 캐스팅을 하고 나면 하위 클래스가 가지고 있는 필드와 메소드 모두 사용 가능 

	public class Ex08_reference {
		public static void main(String[] args) {
			Test8 tt = new Test8(); 
			Demo8 dd = tt;  // <- 실행시 결정 (동적바인딩)
				// 상위 클래스 객체가 하위 클래스 객체를 가르킴 
				// 업 캐스팅(up casting). 언제나 가능 
				// Demo8에 직접 메모리 할당은 X, Test8에 메모리 할당 하며 자동으로 (진짜 dd는 Test8)
			
			System.out.println(tt.b+":"+tt.c); // 200:300
			
			System.out.println(dd.b); // 20 
			dd.print(); // 10:200:300 // 히위 클래스에서 재정의 되면서 상위 클래스의 print는 숨어버림 
									  // 상위 클래스의 객체가 하위 클래스의 객체를 가르키고 있으므로 오버라이딩 된 하위 클래스의 메소드 호출 
									  // 외부에서는 메소드가 오버라이딩 된 경우, 상위 클래스의 메소드 부를 수 없다.
									  // super 사용 불가능 (하위 클래스 안에서만 가능) 
			
		 // System.out.println(dd.c); // 컴오류. dd.c는 실행 전 컴파일 시 결정된다. (실행전에는 dd에 c가 없음)
		}
	}

	class Demo8 {
		int a=10;
		int b=20;
		
		public void print() {
			System.out.println(a+":"+b);
		}
	}

	class Test8 extends Demo8 {
		int b=200;
		int c=300;
		
		public void print() { 
			System.out.println(a+":"+b+":"+c);
		}
		
		public void sub() { 
			super.print(); // 상위 메소드 호출 
			System.out.println(b+":"+c);
		}
	}

	public class Ex09 {
		public static void main(String[] args) {
		
			Demo9 dd1 = new Demo9();
			System.out.println(dd1); // Demo9@해쉬코드 // 진짜 dd1은 Demo객체
			
			Demo9 dd2 = new Test9(); // 업 캐스팅 : 언제나 가능 
			System.out.println(dd2); // Test9@해쉬코드 // 진짜 dd2는 Test객체
			
			dd2.print(); // 오버라이딩 된 하위 클래스 메소드 호출 (print2) 
			dd1.print(); // print1 호출 
	   // → 실행 할 때 결정(동적바인딩), 다형성 
			
			System.out.println(dd2.b); // Demo9의 필드 출력
			// 메소드와 필드는 다르다. 필드는 자기것이 우선적 
			
			// dd2.sub(); // 컴오류 
			// int x = dd2.c; // 컴오류 
			
			int x = ((Test9)dd2).b;    //  ()와 .의 우선순위가 .이 더 높다 
			
		
			// Test9 tt3 = (Test9)dd1; // 다운 캐스팅. 런타임 오류.  
					 // 다운 캐스팅은 업 한 것만 가능하고, 반드시 캐스팅() 해야 함.
			
			Test9 tt = (Test9)dd2; 
			System.out.println(tt.b);

	/*
			- 객체간의 캐스팅은 상하 관계에서만 가능하다.
			- 업 캐스팅은 언제나 가능하다.
			- 다운 캐스팅은 업 한 것만 가능하고 반드시, 캐스팅이 필요하다. 
	 */
			
			System.out.println(dd1 instanceof Test9);  // false
			System.out.println(dd2 instanceof Test9);  // true 
			
			if(dd2 instanceof Test9) {  // 해당 클래스의 객체이면 
				Test9 tt2 = (Test9)dd2; 
				tt2.sub();
			}
		}
	}

	class Demo9 {
		int a=10;
		int b=20;
		
		public void print() {  // print1
			System.out.println(a+":"+b);
		}
	}

	class Test9 extends Demo9 {
		int b=200;
		int c=300; 
		
		public void print() {  // print2
			System.out.println(a+":"+b+":"+c); // 10:200:300
		}
		
		public void sub() { 
			System.out.println(a+":"+super.b+":"+c); // 10:20:300
			super.print();  // print1 호출
			// print(); // print2 호출 
		}
	}
	 
	 
<static 수정자> 


< final >
- 상수의 의미를 가지고 있는 키워드 (불변) 
- 자식 가질 수 x  (ex.String) 
- final 클래스 _ 하위 클래스 가질 수 X 
  final 변수 _ 한번만 초기값 부여. 필드에 붙이면 값을 바꿀 수 없음 (=상수). 대부분 static,대문자로 		   
  final 메소드 _ 재정의 불가  

public class Ex01_final {
	public static void main(String[] args) {
	}
}

/*
final class Sam {  // final 클래스 : 하위 클래스를 가질 수 없다 
	int a; 
}

class Ex extends Sam { // 컴오류 
}
*/

class Demo1 { 
	int a; 
	public final void print() { // 하위 클래스에서 메소드 재정의 불가 
		System.out.println(a);
	}
}

class Test1 extends Demo1 { 
	// public void print() {}   // 컴오류 
	
	final int x;   
	final int y=10; // 컴오류. final 변수는 반드시 한 번 초기화 필요 
	                // 인스턴스 final 변수는 선언시/ 생성자/ 초기화 블럭에서 초기화 가능
	
	static final int A; 
	static final int B=10; 
			// static final 변수는 선언시 or static 초기화 블럭에서 초기화 해야함 
			// 생성자에서는 초기화 불가능 
	
	static {     // static 초기화 블럭 
		A=5; 
	}
	
	public Test1() {
		x=5; 	
	}	
	
	public void write() { 
		final int n=10; 
		// n=20; // 컴오류 . final 변수는 값 변경 불가 
		// x = 25; // 컴오류. final 변수는 값 변경 불가 
		System.out.println(x+":"+y+":"+n);
	}	
}


<Singleton>
- 해당 클래스의 인스턴스를 하나만 만들고, 어디서든지 접근 가능 하게 하는 패턴
- 생성자를 private로 선언 → 인스턴스 접근 위한 public 메소드 제공 
- 공통된 객체가 필요한 경우 사용 [전역 인스턴스] 

public class Ex02_singleton {
	public static void main(String[] args) {
	 // SingletonEx1 ob = new Singletonex1(); // 컴오류
											   // 생성자가 private 
		SingletonEx1 ob1 = SingletonEx1.getInstance();
		SingletonEx1 ob2 = SingletonEx1.getInstance();
		
		System.out.println(ob1==ob2);  // true 
		
		ob1.print();
		
	}
}

class SingletonEx1 {  // 객체를 하나만 생성하고 더이상 생성하지 못하게 할 때 사용 
	private static SingletonEx1 inst; 
	
	private SingletonEx1() {  // 1.생성자를 private으로 만든다
	}
	
	public static SingletonEx1 getInstance() { // 2.객체를 생성하는 class 메소드를 만든다
		if(inst==null) {
			inst = new SingletonEx1(); 
		}
		return inst;
	}
	
	public void print() {
		System.out.println("Singleton 패턴 예제 1...");
	}
}

public class Ex03 {
	public static void main(String[] args) {
		SingletonEx2 ob1 = SingletonEx2.getInstance();
		SingletonEx2 ob2 = SingletonEx2.getInstance();
		System.out.println(ob1==ob2);       // true 
	}
}

class SingletonEx2 {  // 진정한 의미의 Singleton 
	private SingletonEx2() {
	}

	// static 중첩 클래스 _ 멀티쓰레드 환경에서도 객체를 하나만 생성 가능
	private static class Holder {
		public static final SingletonEx2 INST = new SingletonEx2();
	}

	public static SingletonEx2 getInstance() {
		return Holder.INST;
	}
}


<추상클래스>
- 선언만 있고 정의가 없는 추상 메소드를 적어도 하나 갖는 클래스 
- 정의가 없으므로 객체 생성이 불가능  
- abstract class 
- final, static 과는 함께 사용 불가 (하위 클래스가 반드시 있어야 하므로)
- 추상 메소드가 없어도 되지만, 이 경우에도 객체 생성은 불가능

/* 추상 클래스를 만드는 이유 
--------selection sort 
필드		value[] : int 
메소드 	정렬/ 비교 / 바꾸기/ 길이 

--------bubble sort 
필드		value[] : int 
메소드 	정렬/ 비교 / 바꾸기/ 길이 

selection sort와 bubble sort는 정렬외에는 같은 메소드 사용한다.
selection을 bubble에 상속하여 사용하여도 되지만, 쓸데없이 메모리가 낭비된다. 
정렬만 추상 메소드로 만들고, 나머지 메소드는 완성 된  추상 클래스 sort 를 만들면 다음과 같이 할 수 있다. ↓ 

--------sort
필드		value[] : int 
메소드 	정렬  → abstract 
		비교/ 바꾸기/ 길이 

--------selection sort 
필드
메소드 	정렬 구현

--------bubble sort 
필드		
메소드 	정렬 구현
*/

public class Ex04_abstract {
	public static void main(String[] args) {
		int [] nn = {25, 10, 5, 89, 70, 55};
		
		// SortInt aa = new SortInt(); // 컴오류. 추상클래스는 객체 생성 불가
		
		// SortInt ss = new BubbleSort();
		SortInt ss = new SelectionSort();
		
		System.out.print("source data : ");
		for(int n : nn) {
			System.out.print(n+" ");
		}
		System.out.println();
		
		ss.sort(nn);
		
		System.out.print("sort data : ");
		for(int n : nn) {
			System.out.print(n+" ");
		}
		System.out.println();
	}
}

abstract class SortInt { // 추상 클래스 : 미완성된 클래스. 반드시 자식이 있어야 사용 가능(final, static 불가)
						 // 추상 메소드가 하나라도 있으면 추상 클래스로 만들어야 한다. 
						 // 추상 메소드가 없어도 추상 클래스로 만들 수 있다. (그래도 객체 생성은 못 함) 
	private int[] value; 
	protected abstract void sorting();  // 추상 메소드 → {}가 없다. 정의X 
	
	public void sort(int[] value) {
		this.value = value; 
		sorting(); 
	}
	
	protected int length() { 
		return value == null ? -1 : value.length;
	}
	
	protected final int compare(int i, int j) { 
		return value[i] - value[j]; 
	}
	
	protected void swap(int i, int j) {
		int t = value[i];
		value[i] = value[j];
		value[j] = t; 
	}	
}

// 추상 쿨래스를 상속 받은 클래스가 추상 클래스가 아니면, 반드시 모든 추상 메소드를 재정의 해야 한다.
class SelectionSort extends SortInt {

	@Override
	protected void sorting() {
		for(int i=0; i<length()-1; i++) {
			for(int j=i+1; j<length(); j++) {
				if(compare(i,j)>0) {
					swap(i,j);
				}
			}
		}		
	} 
}

class BubbleSort extends SortInt {

	@Override
	protected void sorting() {
		int pass=1;
		boolean flag; 
		
		do { 
			flag = false; 
			for(int i=0; i<length()-pass; i++) {
				if(compare(i, i+1)>0) {
					swap(i, i+1);
					flag=true;
				}
			}
			pass++;
		} while(flag);
	} 
}			


















	 
