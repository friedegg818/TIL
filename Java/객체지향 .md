# 객체지향 프로그래밍

**Object-Oriented Programming** 


### 프로그래밍
#### 절차지향 
  - 문제를 해당되는 순서로 순차적으로 처리하는 기법 
  - 순서는 변하지 않음
  - 루틴, 메소드, 함수 등
  - C언어가 대표적 
#  
  - 장점 _ 컴퓨터 처리 방식과 유사, 속도가 빠름 
  - 단점 _ 중복적인 소스가 많이 들어갈 수 있음(재사용, 유지보수가 어려움)
  - 특징 
    - 코드 중심 ('일, 프로그램' 중심)    
    - 명령어 결정 후 데이터 요청 (데이터가 더 중요함)   
    - Top-Down 방식    
    - 대규모 프로그래밍 환경에 미흡    
#
#### 객체지향
   - 실제 세계를 모델링 하여 소프트웨어 개발 (소프트웨어 객체 모델링)
   - 메세지 교환(통신)을 통해 상호작용함으로써 전체 시스템 운영
   - 현실 세계의 개체 > 속성(데이터) + 메소드(행위) = 객체    
      → 데이터와 절차를 하나의 덩어리로 묶어서 생각
   - java, c++, c#, python이 대표적
#   
   - 특징 
     - 데이터 중심
     - 데이터 정의 후 명령어 추가
     - 성능 < 개발의 편리성, 효율성 
     - 생산성 향상 (쉬운 프로그램 개발)
     - 재사용 가능 및 유지 보수 용이
     - 객체를 조립해서 프로그램을 만든다. 
#		 
#### 객체 	
   - 우리 주위에 손쉽게 있는 모든 물리적 사물, '실체'
   - 특성, 행위, 정체성    
   - 데이터 + 코드를 하나로 묶는 구성 단위 
   - 개발 시간에는 레퍼런스 변수(참조형) 
   - 실행 시간에는 인스턴스 (메모리를 할당 받은 객체)
#   
   - 구성
     - **상태(데이터)** + **동작(행위)**   
       = 속성(property,attribute) + 프로시저    
       = 필드(멤버변수) + 메소드(멤버함수)     
#
#### 객체지향 구성요소 
   - **클래스** : 객체를 만들기 위한 틀. 속성과 메소드로 구성
   - **객체** : 메모리 할당을 받은 것. 실제로 생성된 실체  
   - **속성** 
   - **메소드/메세지** 

#
#### 추상화 
   - 객체에서 공통된 속성과 행위를 추출하는 것    
      → 현실 세계의 사물을 데이터 + 기능적 측면으로 정의 
   - 클래스 정의도 추상화
#
#### 캡슐화 
   - 속성 + 행위를 논리적으로 하나로 묶어 놓은 것 
   - 실제 구현 내용은 외부에 감추어 은닉
   - 외부에서 접근 할 수 있도록 정의된 기기를 통해서만 관련 데이터 접근 가능
   - 필요한건 노출하고 불필요한 것은 감추기    
#   
   - 장점 
     - 데이터 보호. 손상오용 방지 
     - 추상화 용이 
     - 제공자와 이용자 명확히 분리 (만드는사람!=사용자)
     - 편리성↑ (기능이 바뀌어도 사용방법은 변하지 않음)
     - 변경 용이성, 재사용성↑
 #
#### 상속
- 클래스의 속성과 행위를 하위 클래스에 물려주거나, 상위 클래스에서 물려 받는 것 
- 상위(super)클래스 / 하위(sub)클래스 
#
- 장점 
  - 개별 클래스를 상속 관계로 묶음으로써 클래스 간 체계화 된 전체 구조 파악이 용이 
  - 데이터와 메소드의 오버로딩을 피하고, 기존 클래스에 있는 것 재사용 가능 
  - 새로운 클래스/데이터/메소드 추가가 용이
  - 데이터와 메소드를 변경 할 때 상위에 있는 것만 수정하여 전체적으로 일관성을 유지 할 수 있음
#
####  다형성 
- '여러 개의 형태를 갖는다'는 의미 
- **Overloading** (중복정의) _ 동일한 이름의 Operation 사용 
- **Overriding** (재정의) _ 상위 클래스의 메소드를 하위 클래스에서 재정의

#
#### 설계 원칙 
- 단일 책임의 원칙 : 하나의 클래스에는 한가지 기능만 두어야 함 
- 개방/폐쇄의 원칙 : 확장에 대해서는 개방, 변경에 대해서는 폐쇄 
- 인터페이스 분리의 원칙 : 클라이언트는 자신이 사용하지 않는 메소드와 의존 관계를 갖지 않도록 해야 함 
- 리스코프 치환의 원칙 : 서브 타입은 언제나 기반 타입으로 대체 할 수 있어야 함 
- 의존 관계 역전의 원칙 : 고차원 모듈은 저차원 모듈에 의존 하면 안됨 (추상클래스/인터페이스 사용 권장) 
