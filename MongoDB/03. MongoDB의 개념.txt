■ Mongodb 개념
   ο MongoDB 기본 개념
     MongoDB는 여러 데이터베이스를 서비스한다. 데이터베이스(database)란 데이터를 저장하는 컨테이너로 행동하며 서로 독립적이다.
     MongoDB 데이터베이스 하나에는 한 개 이상의 컬렉션이 들어있다.
 
     컬렉션(collection)은 다큐먼트(document)들의 집합입니다. 컬렉션은 관계형 데이터베이스의 테이블 개념과 논리적으로 유사하지만 테이블과는 달리, 컬렉션을 저장하기 앞서 데이터 구조를 미리 정의할 필요는 없다. 예를 들면, 블로깅 애플리케이션을  위한  데이터베이스는 일반적으로 아티클(articles), 저자(authors), 댓글(comments), 카테고리(categories) 같은 컬렉션을 포함한다.
 
     컬렉션에 저장된 다큐먼트(문서, document)는 데이터 단위이다. 다큐먼트는 키-값 쌍이나 필드 집합을 포함하는데, 키(key)는 문자열이며, 값(value)은 문자열, 정수, 부동소수, 타임스탬프 같은 다양한 타입이 될 수 있다. 다큐먼트의 필드 값으로 다른 다큐먼트를 저장할 수도 있다.

     데이터베이스 > 컬렉션(collection, 테이블) > 다큐먼트(문서, document)


   ο MongoDB 쉘
     MongoDB 쉘 애플리케이션은 bin 폴더에 MongoDB 배포판과 함께 포함되어 있다.
     Windows에서는 이 쉘이 애플리케이션(mongo.exe)으로 존재하며, UNIX® 기반 운영 체제(Mac OS X 포함)에서는 터미널 창에서 mongo 명령을 실행하여 MongoDB 쉘을 시작할 수 있다.

     cmd>mongo
     >

     MongoDB 함수의 소스 코드를 알고 싶으면 쉘에서 해당 함수의 이름을 입력하기만 하면 해당하는 Javascript 소스가 표시된다. 예를 들면, connect를 입력하고 리턴 키를 누르면 MongoDB 데이터베이스에 연결하는 데 사용된 소스 코드가 표시된다.

     MongoDB 쉘은 Javascript를 사용하므로 데이터베이스와 상호 작용할 때 일반 Javascript 구문을 작성할 수 있다.

     기본적으로 Mongo 쉘은 "test" 데이터베이스에 연결된다. 다른 데이터베이스로 전환하려면 "use dbname" 명령을 사용한다. 데이터베이스가 존재하지 않는 경우에는 데이터를 데이터베이스에 추가하는 즉시 MongoDB에서 데이터베이스가 작성된다.
     
     >use mymongo 명령을 사용하여 "mymongo" 데이터베이스로 전환한다.


   ο 문서(Document) 
     몽고 DB 의 핵심은 정렬된 키와 연결된 값의 집합으로 이루어진 문서이다.
 
     {"a" : "Hello, Mongo!"} 
 
     위 중괄호({})로 묶인 부분이 몽고 DB 에서의 가장 간단한 '문서'라는 개념이다. 이 문서는 그리팅("a")이라는 하나의 키에 연결된 "Hello, Mongo!"라는 값을 갖는다.
 
     ◆ 하나의 문서 안에  2개 이상의 키-값 쌍이 들어 갈 수도 있다. 
       {"a" : "Hello, Mongo!", "b" : "Thank you!"} 

       문서의 키-값 쌍은 정렬되어 있다. 따라서 다음 두 문서는 다른 문서로 취급된다. 
 
       {"a" : "Hello, Mongo!", "b" : "Thank you!"} 
       != {"a" : "Thank you!",  "b" : "Hello, Mongo!"} 
 
     ◆ 문서의 키는 문자열 형이다. 
       - 키는 \0(null 문자)을 포함하지 않는다. 이 문자는 키의 끝을 나타내는데 쓰이기 때문이다.
       - '.' 과 '$' 문자는 몇 가지 특별한 속성을 가지고 있으며 특정 상황에서만 사용해야 한다. 이 문자들은 보통 예약어로 취급해야 하며, 부적절하게 사용하는 경우 드라이버에서 경고가 발생하게 된다.
       - 엄격하게 지켜지는 것은 아니지만 일반적으로 '_'로 시작하는 키는 예약어이다.
 
     ◆ 몽고 DB 는 데이터형과 대소문자를 구별한다.
       {"Number" : 13}  ... 문서(1)
       {"Number" : "13"} ... 문서(2)

       위 문서(1)과 문서(2)는 데이터형이 다르기 때문에 다른 문서이다.
 
       {"Number" : 13} ... 문서(3)
       {"number" : 13}... 문서(4)
 
      위 두 개의 문서(1)과 문서(2)는 키(key)의 대소문자가 다르기 때문에 다른 문서이다.
 
     ◆ 문서내의 키는 중복될 수 없다.
       {"a" : "test1", "a" : "test2"} 
       위 문서처럼 키 값으로 "a"이 중복될 수 없다. 
 
     ◆ 문서의 값으로 사용될 수 있는 데이터형 정리 
       ① null 형
         존재하지 않는 필드를 표현하는데 사용될 수 있다. 
         { "x" : null } 
 
       ② boolean 형
         'true'와 'false' 값을 표현하는데 사용될 수 있다. 
         { "x" : false } 
 
       ③ 64비트 부동소수점형
         쉘 내의 모든 숫자는 이 데이터형으로 된다. 
         { "x" : 3.14 }, { "x" : 3 } 
         cf) 쉘 내에서는 '32 비트 정수형', '64 비트 정수형'은 표현되지 않는다. 왜냐하면 JavaScript 는 64 비트 float형을 지원하기 때문이다. 위 두 가지 수 데이터 타입은 모두 64비트 부동소수점형으로 변환된다.
 
       ④ 문자열형
         모든 UTF-8 문자열은 문자열형으로 표현될 수 있다.
         { "x" : "MongoDB" } 
 
       ⑤ 심볼형
         이 데이터 타입은 쉘에서는 지원하지 않는다. 데이터베이스에서 심볼형을 받게 되면 쉘에서 문자열로 변환시킨다.
 
       ⑥ 객체 ID 형
         객체 ID 형은 문서의 고유한 12 바이트 ID 이다. 
         { "x" : ObjectID() } 

       ⑦ 날짜형
         날짜형은 1970년 1월 1일 이후의 시간 흐름을 1/1000 초로 저장한다. 표준시간대는 저장하지 않는다.
         { "x" : new Date() } 
 
       ⑧ 정규표현식
         문서는 자바스크립트 문법의 정규표현식을 포함할 수 있다.
         { "x" : /footbar/i } 
 
       ⑨ 코드형
         문서는 자바스크립트 코드도 포함할 수 있다.
         { "x" : function() { /* ... */ } } 
 
       ⑩ 이진데이터형 
         이진 데이터형은 임의의 바이트 문자열로 쉘에서는 조작할 수 없다.
 
       ⑪ undefined 
         undefined 를 문서 내에서 사용할 수 있다.
         { "x" : undefined }
         cf) 자바스크립트에서는 null과 undefined 를 구별한다.
 
       ⑫ 배열 
         값의 집합 또는 목록을 배열로 표현할 수 있다. 
         { "x" : ["a", "b", "c"]} 
 
       ⑬ 내장 문서 
         부모 문서에서 값으로 내장되는 형태로 문서는 문서를 포함할 수 있다.
         { "x" : { "number" : 3} }


   ο 조건부 연산자
     - $lt : 미만
     - $lte : 이하 
     - $gt : 초과
     - $gte : 이상
     - $all : 배열에 있는 모든 값과 일치
     - $exists : 필드의 존재 여부 확인
     - $mod : 모듈
     - $ne : 같지 않음
     - $in : 배열에 있는 하나 이상의 값과 일치
     - $nin : 배열에 있는 0 값과 일치
     - $or : 쿼리 중 하나와 일치
     - $nor : 쿼리 중 어느 것과도 일치하지 않음
     - $size : 정의된 요소 수가 있는 배열과 일치
     - $type : 지정된 BSON 데이터 유형의 값과 일치
     - $not : 같지 않음


   ο 컬렉션(Collection) 
     컬렉션은 문서의 모음으로 문서(Document)가 RDBMS 에서의 '행'이라면, 컬렉션은 '테이블'이라 생각할 수 있다. 
 
     ◆ 스키마가 없다. 
       컬렉션은 스키마가 없기 때문에 하나의 컬렉션 내 문서들이 모두 다른 구조를 가질 수 있다. 
 
       {"a" : "Thank you!"} 
       {"Number" : 5} 
 
       위 두 문서들은 값의 데이터형(문자열형 vs 정수형)이 다르고 스키마도 완전히 다르지만 하나의 컬렉션 안에 같이 저장할 수 있다. 
 
     ◆ 컬렉션 이름 작성 시 유의사항 
       - 컬렉션의 이름은 어떤 UTF-8 문자열도 사용할 수 있다. 
       - 빈 문자열("")은 컬렉션 이름으로 사용할 수 없다. 
       - \0(null 문자)는 컬렉션 이름의 끝을 나타내는 문자이기 때문에 컬렉션 이름에 사용할 수 없다. 
       - 컬렉션 이름을 'system'으로 시작하면 안 된다. 'system'으로 시작하는 컬렉션들이 시스템 컬렉션으로 사용되기 때문이다. 
       - 사용자가 만드는 컬렉션 이름에 '$'문자는 사용할 수 없다. 데이터베이스가 제공하는 다양한 드라이버 들이 시스템에서 생성한 컬렉션에서 '$'문자를 사용하기 때문에, 이런 컬렉션들 중 하나에 의도적으로 접 근하는 것이 아니라면 '$'를 컬렉션 이름에 사용하면 안 된다. 
 

   ο 데이터베이스(Database) 
     몽고 DB는 문서를 컬렉션으로 모아 두고, 이 여러 컬렉션들을 데이터베이스에 모아둔다. 하나의 데이터베이스는 따로 분리된 파일로 디스크에 저장된다. 
 
     컬렉션과 마찬가지로, 데이터베이스 또한 이름으로 식별되기 때문에 데이터베이스 이름을 작성하는데 있어서도 몇가지 규칙이 있다. 
 
     - 데이터베이스 이름은 어떤 UTF-8 타입의 문자열도 사용할 수 있다. 
     - 데이터베이스 이름을 작성하는데 있어 '\0'(null  문자), '$', '.', '/', '\', ' '(공백문자) 들은 사용할 수 없다. 
     - 데이터베이스 이름은 모두 소문자이어야 한다.
     - 데이터베이스 이름은 최대 64바이트이다. 


   ο MySQL 용어와 Mongo 용어 비교  
     MySQL 용어		Mongo 용어
     -----------------------------------------
     database	database  
     table		collection  
     index		index 
     row		BSON document 
     column	BSON field 
     join		embedding and linking 


   ο SQL 문장과 mongo 쿼리 문장 비교
     - CREATE TALE USERS (a int, b int)
       db.createCollection("mycoll")

     - INSERT INTO USERS VALUES (3,5)
       db.users.insert({a:3, b:5})

     - SELECT a, b FROM USERS
       db.users.find({}, {a:1, b:1})  
     - SELECT * FROM users
       db.users.find() 
     - SELECT * FROM users WHERE age=33
       db.users.find({age:33}) 
     - SELECT a,b FROM users WHERE age=33
       db.users.find({age:33}, {a:1,b:1}) 
     - SELECT * FROM users WHERE age=33 ORDER BY name
       db.users.find({age:33}).sort({name:1}) 
     - SELECT * FROM users WHERE age>33
       db.users.find({'age':{$gt:33}}) 
     - SELECT * FROM users WHERE age<33
       db.users.find({'age':{$lt:33}}) 
     - SELECT * FROM users WHERE name LIKE "%Joe%"
       db.users.find({name:/Joe/}) 
     - SELECT * FROM users WHERE name LIKE "Joe%"
       db.users.find({name:/^Joe/}) 
     - SELECT * FROM users WHERE age>33 AND age<=40
       db.users.find({'age':{$gt:33,$lte:40}}) 
     - SELECT * FROM users ORDER BY name DESC
       db.users.find().sort({name:-1}) 
     - SELECT * FROM users WHERE a=1 and b='q'
       db.users.find({a:1,b:'q'}) 
     - SELECT * FROM users WHERE a=1 or b=2
       db.users.find( { $or : [ { a : 1 } , { b : 2 } ] } ) 

     - SELECT * FROM users LIMIT 1
       db.users.findOne() 

     - SELECT DISTINCT last_name FROM users
       db.users.distinct('last_name') 

     - SELECT COUNT(*) FROM users
       db.users.count() 
     - SELECT COUNT(*) FROM users where AGE > 30
       db.users.find({age: {'$gt': 30}}).count() 
     - SELECT COUNT(AGE) from users
       db.users.find({age: {'$exists': true}}).count() 

     - CREATE INDEX myindexname ON users(name)
       db.users.ensureIndex({name:1}) 
     - CREATE INDEX myindexname ON users(name,ts DESC)
       db.users.ensureIndex({name:1,ts:-1}) 

     - EXPLAIN SELECT * FROM users WHERE z=3
       어떻게 SELECT가 진행되었는지, 어떤 테이블이 어떤 순서로 JOIN 되었는지 등에 관한 정보를 출력
       db.users.find({z:3}).explain() 

     - UPDATE users SET a=1 WHERE b='q'
       db.users.update({b:'q'}, {$set:{a:1}}, false, true) 
     - UPDATE users SET a=a+2 WHERE b='q'
       db.users.update({b:'q'}, {$inc:{a:2}}, false, true) 

     - DELETE FROM users WHERE z="abc"
       db.users.remove({z:'abc'})
 