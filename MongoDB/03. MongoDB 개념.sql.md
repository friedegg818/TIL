# MongoDB 기본 개념
 - 데이터베이스(database) : 데이터를 저장하는 컨테이너로 행동 하며 서로 독립적
 - MongoDB는 여러 데이터베이스를 서비스 하며, 데이터베이스 하나에는 한 개 이상의 컬렉션이 들어 있음

#
### MongoDB 쉘
  - MongoDB 쉘 애플리케이션은 bin 폴더에 MongoDB 배포판과 함께 포함
  - Windows에서는 애플리케이션(mongo.exe)으로 존재
  - UNIX 기반 운영 체제(Mac OS X 포함)에서는 터미널 창에서 mongo 명령을 실행하여 MongoDB 쉘을 시작 할 수 있음
   
        cmd>mongo
   
  - 쉘에서 함수의 이름을 입력하면 해당 함수의 Javascript 소스 표시  
      
        ex) connect를 입력하고 리턴 키를 누르면 MongoDB 데이터베이스에 연결하는 데 사용된 소스 코드가 표시 

  - 쉘은 Javascript를 사용하므로 데이터베이스와 상호 작용할 때 일반 Javascript 구문을 작성 할 수 있음

  - 기본적으로 **test 데이터베이스**에 연결되며 다른 데이터베이스로 전환하려면 **use dbname** 명령사용
  
         >use mymongo 명령을 사용하여 "mymongo" 데이터베이스로 전환
  
  - 데이터베이스가 존재하지 않는 경우, 데이터를 데이터베이스에 추가하는 즉시 MongoDB에서 데이터베이스가 작성됨


#
### 문서(Document) 
     몽고 DB 의 핵심은 정렬된 키와 연결된 값의 집합으로 이루어진 문서이다.
 
     {"a" : "Hello, Mongo!"} 
 
     위 중괄호({})로 묶인 부분이 몽고 DB 에서의 가장 간단한 '문서'라는 개념이다. 이 문서는 그리팅("a")이라는 하나의 키에 연결된 "Hello, Mongo!"라는 값을 갖는다.
 
     ◆ 하나의 문서 안에  2개 이상의 키-값 쌍이 들어 갈 수도 있다. 
       {"a" : "Hello, Mongo!", "b" : "Thank you!"} 

       문서의 키-값 쌍은 정렬되어 있다. 따라서 다음 두 문서는 다른 문서로 취급된다. 
 
       {"a" : "Hello, Mongo!", "b" : "Thank you!"} 
       != {"a" : "Thank you!",  "b" : "Hello, Mongo!"} 
 
     ◆ 문서의 키는 문자열 형이다. 
       - 키는 \0(null 문자)을 포함하지 않는다. 이 문자는 키의 끝을 나타내는데 쓰이기 때문이다.
       - '.' 과 '$' 문자는 몇 가지 특별한 속성을 가지고 있으며 특정 상황에서만 사용해야 한다. 이 문자들은 보통 예약어로 취급해야 하며, 부적절하게 사용하는 경우 드라이버에서 경고가 발생하게 된다.
       - 엄격하게 지켜지는 것은 아니지만 일반적으로 '_'로 시작하는 키는 예약어이다.
 
     ◆ 몽고 DB 는 데이터형과 대소문자를 구별한다.
       {"Number" : 13}  ... 문서(1)
       {"Number" : "13"} ... 문서(2)

       위 문서(1)과 문서(2)는 데이터형이 다르기 때문에 다른 문서이다.
 
       {"Number" : 13} ... 문서(3)
       {"number" : 13}... 문서(4)
 
      위 두 개의 문서(1)과 문서(2)는 키(key)의 대소문자가 다르기 때문에 다른 문서이다.
 
     ◆ 문서내의 키는 중복될 수 없다.
       {"a" : "test1", "a" : "test2"} 
       위 문서처럼 키 값으로 "a"이 중복될 수 없다. 
 
     ◆ 문서의 값으로 사용될 수 있는 데이터형 정리 
       ① null 형
         존재하지 않는 필드를 표현하는데 사용될 수 있다. 
         { "x" : null } 
 
       ② boolean 형
         'true'와 'false' 값을 표현하는데 사용될 수 있다. 
         { "x" : false } 
 
       ③ 64비트 부동소수점형
         쉘 내의 모든 숫자는 이 데이터형으로 된다. 
         { "x" : 3.14 }, { "x" : 3 } 
         cf) 쉘 내에서는 '32 비트 정수형', '64 비트 정수형'은 표현되지 않는다. 왜냐하면 JavaScript 는 64 비트 float형을 지원하기 때문이다. 위 두 가지 수 데이터 타입은 모두 64비트 부동소수점형으로 변환된다.
 
       ④ 문자열형
         모든 UTF-8 문자열은 문자열형으로 표현될 수 있다.
         { "x" : "MongoDB" } 
 
       ⑤ 심볼형
         이 데이터 타입은 쉘에서는 지원하지 않는다. 데이터베이스에서 심볼형을 받게 되면 쉘에서 문자열로 변환시킨다.
 
       ⑥ 객체 ID 형
         객체 ID 형은 문서의 고유한 12 바이트 ID 이다. 
         { "x" : ObjectID() } 

       ⑦ 날짜형
         날짜형은 1970년 1월 1일 이후의 시간 흐름을 1/1000 초로 저장한다. 표준시간대는 저장하지 않는다.
         { "x" : new Date() } 
 
       ⑧ 정규표현식
         문서는 자바스크립트 문법의 정규표현식을 포함할 수 있다.
         { "x" : /footbar/i } 
 
       ⑨ 코드형
         문서는 자바스크립트 코드도 포함할 수 있다.
         { "x" : function() { /* ... */ } } 
 
       ⑩ 이진데이터형 
         이진 데이터형은 임의의 바이트 문자열로 쉘에서는 조작할 수 없다.
 
       ⑪ undefined 
         undefined 를 문서 내에서 사용할 수 있다.
         { "x" : undefined }
         cf) 자바스크립트에서는 null과 undefined 를 구별한다.
 
       ⑫ 배열 
         값의 집합 또는 목록을 배열로 표현할 수 있다. 
         { "x" : ["a", "b", "c"]} 
 
       ⑬ 내장 문서 
         부모 문서에서 값으로 내장되는 형태로 문서는 문서를 포함할 수 있다.
         { "x" : { "number" : 3} }


   ο 조건부 연산자
     - $lt : 미만
     - $lte : 이하 
     - $gt : 초과
     - $gte : 이상
     - $all : 배열에 있는 모든 값과 일치
     - $exists : 필드의 존재 여부 확인
     - $mod : 모듈
     - $ne : 같지 않음
     - $in : 배열에 있는 하나 이상의 값과 일치
     - $nin : 배열에 있는 0 값과 일치
     - $or : 쿼리 중 하나와 일치
     - $nor : 쿼리 중 어느 것과도 일치하지 않음
     - $size : 정의된 요소 수가 있는 배열과 일치
     - $type : 지정된 BSON 데이터 유형의 값과 일치
     - $not : 같지 않음

#
### 컬렉션(Collection) 
     컬렉션은 문서의 모음으로 문서(Document)가 RDBMS 에서의 '행'이라면, 컬렉션은 '테이블'이라 생각할 수 있다. 
 
     ◆ 스키마가 없다. 
       컬렉션은 스키마가 없기 때문에 하나의 컬렉션 내 문서들이 모두 다른 구조를 가질 수 있다. 
 
       {"a" : "Thank you!"} 
       {"Number" : 5} 
 
       위 두 문서들은 값의 데이터형(문자열형 vs 정수형)이 다르고 스키마도 완전히 다르지만 하나의 컬렉션 안에 같이 저장할 수 있다. 
 
     ◆ 컬렉션 이름 작성 시 유의사항 
       - 컬렉션의 이름은 어떤 UTF-8 문자열도 사용할 수 있다. 
       - 빈 문자열("")은 컬렉션 이름으로 사용할 수 없다. 
       - \0(null 문자)는 컬렉션 이름의 끝을 나타내는 문자이기 때문에 컬렉션 이름에 사용할 수 없다. 
       - 컬렉션 이름을 'system'으로 시작하면 안 된다. 'system'으로 시작하는 컬렉션들이 시스템 컬렉션으로 사용되기 때문이다. 
       - 사용자가 만드는 컬렉션 이름에 '$'문자는 사용할 수 없다. 데이터베이스가 제공하는 다양한 드라이버 들이 시스템에서 생성한 컬렉션에서 '$'문자를 사용하기 때문에, 이런 컬렉션들 중 하나에 의도적으로 접 근하는 것이 아니라면 '$'를 컬렉션 이름에 사용하면 안 된다. 
 
#
### 데이터베이스(Database) 
     몽고 DB는 문서를 컬렉션으로 모아 두고, 이 여러 컬렉션들을 데이터베이스에 모아둔다. 하나의 데이터베이스는 따로 분리된 파일로 디스크에 저장된다. 
 
     컬렉션과 마찬가지로, 데이터베이스 또한 이름으로 식별되기 때문에 데이터베이스 이름을 작성하는데 있어서도 몇가지 규칙이 있다. 
 
     - 데이터베이스 이름은 어떤 UTF-8 타입의 문자열도 사용할 수 있다. 
     - 데이터베이스 이름을 작성하는데 있어 '\0'(null  문자), '$', '.', '/', '\', ' '(공백문자) 들은 사용할 수 없다. 
     - 데이터베이스 이름은 모두 소문자이어야 한다.
     - 데이터베이스 이름은 최대 64바이트이다. 

#
### MySQL 용어와 Mongo 용어 비교  
     MySQL 용어		Mongo 용어
     -----------------------------------------
     database	database  
     table		collection  
     index		index 
     row		BSON document 
     column	BSON field 
     join		embedding and linking 

#
### SQL 문장과 mongo 쿼리 문장 비교
     - CREATE TALE USERS (a int, b int)
       db.createCollection("mycoll")

     - INSERT INTO USERS VALUES (3,5)
       db.users.insert({a:3, b:5})

     - SELECT a, b FROM USERS
       db.users.find({}, {a:1, b:1})  
     - SELECT * FROM users
       db.users.find() 
     - SELECT * FROM users WHERE age=33
       db.users.find({age:33}) 
     - SELECT a,b FROM users WHERE age=33
       db.users.find({age:33}, {a:1,b:1}) 
     - SELECT * FROM users WHERE age=33 ORDER BY name
       db.users.find({age:33}).sort({name:1}) 
     - SELECT * FROM users WHERE age>33
       db.users.find({'age':{$gt:33}}) 
     - SELECT * FROM users WHERE age<33
       db.users.find({'age':{$lt:33}}) 
     - SELECT * FROM users WHERE name LIKE "%Joe%"
       db.users.find({name:/Joe/}) 
     - SELECT * FROM users WHERE name LIKE "Joe%"
       db.users.find({name:/^Joe/}) 
     - SELECT * FROM users WHERE age>33 AND age<=40
       db.users.find({'age':{$gt:33,$lte:40}}) 
     - SELECT * FROM users ORDER BY name DESC
       db.users.find().sort({name:-1}) 
     - SELECT * FROM users WHERE a=1 and b='q'
       db.users.find({a:1,b:'q'}) 
     - SELECT * FROM users WHERE a=1 or b=2
       db.users.find( { $or : [ { a : 1 } , { b : 2 } ] } ) 

     - SELECT * FROM users LIMIT 1
       db.users.findOne() 

     - SELECT DISTINCT last_name FROM users
       db.users.distinct('last_name') 

     - SELECT COUNT(*) FROM users
       db.users.count() 
     - SELECT COUNT(*) FROM users where AGE > 30
       db.users.find({age: {'$gt': 30}}).count() 
     - SELECT COUNT(AGE) from users
       db.users.find({age: {'$exists': true}}).count() 

     - CREATE INDEX myindexname ON users(name)
       db.users.ensureIndex({name:1}) 
     - CREATE INDEX myindexname ON users(name,ts DESC)
       db.users.ensureIndex({name:1,ts:-1}) 

     - EXPLAIN SELECT * FROM users WHERE z=3
       어떻게 SELECT가 진행되었는지, 어떤 테이블이 어떤 순서로 JOIN 되었는지 등에 관한 정보를 출력
       db.users.find({z:3}).explain() 

     - UPDATE users SET a=1 WHERE b='q'
       db.users.update({b:'q'}, {$set:{a:1}}, false, true) 
     - UPDATE users SET a=a+2 WHERE b='q'
       db.users.update({b:'q'}, {$inc:{a:2}}, false, true) 

     - DELETE FROM users WHERE z="abc"
       db.users.remove({z:'abc'})
 
